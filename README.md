# Лабораторная работа №2. Вариант 2
## Белякова Кира
### 1.3.
Дан набор целых чисел с четным количеством элементов. Заполнить вектор V исходными числами, вывести вначале вторую половину элементов вектора V, а затем первую половину (в каждой половине порядок элементов не изменять).
1. Считываю числа в вектор
2. Проверяю что количество элементов четное
3. Вывожу вторую половину вектора (от середины до конца)
4. Вывожу первую половину вектора (от начала до середины)
```
Введите целые числа через пробел (четное количество):
1 2 3 4
Все элементы вектора: 1 2 3 4 
Результат: 3 4 1 2 
```
```
Введите целые числа через пробел (четное количество):
1 2 3
Ошибка: количество элементов должно быть четным! 
```
```
Введите целые числа через пробел (четное количество):

Ошибка: не введено ни одного числа!
```
### 2.3.
Даны вектор V и список L. Каждый исходный контейнер содержит не менее 5 элементов. Вставить после элемента списка с порядковым номером 5 первые 5 элементов вектора в обратном порядке. Использовать один вызов функции-члена insert
1. Считываю вектор V и список L
2. Проверяю что оба содержат >= 5 элементов
3. Нахожу 5-ю позицию в списке L
4. Беру первые 5 элементов вектора V и разворачиваю их
5. Вставляю развернутые элементы после 5-го элемента списка L
```
Введите элементы вектора V (минимум 5 чисел через пробел):
1 2 3 4 5
Введите элементы списка L (минимум 5 чисел через пробел):
6 7 8 9 0

Исходный вектор V: 1 2 3 4 5 
Исходный список L: 6 7 8 9 0 
Список L после вставки: 6 7 8 9 0 5 4 3 2 1 
```
```
Введите элементы вектора V (минимум 5 чисел через пробел):
1
Ошибка: вектор должен содержать не менее 5 элементов!
```
```
Введите элементы вектора V (минимум 5 чисел через пробел):
1 2 3 4 5
Введите элементы списка L (минимум 5 чисел через пробел):
1
Ошибка: список должен содержать не менее 5 элементов!
```
### 3.7.
Даны списки L1 и L2, имеющие четное количество элементов. Поменять местами первую половину исходного списка L1 и вторую половину исходного списка L2. Использовать два вызова функции-члена splice.
1. Считываю два списка L1 и L2
2. Проверяю что оба имеют четное количество элементов
3. Сохраняю первую половину L1 во временный список
4. Перемещаю вторую половину L2 в начало L1
5. Перемещаю сохраненную первую половину L1 в конец L2
```
Введите элементы списка L1 (четное количество чисел через пробел):
1 2 3 4 
Введите элементы списка L2 (четное количество чисел через пробел):
5 6 7 8 
Исходный список L1: 1 2 3 4     
Исходный список L2: 5 6 7 8     
Список L1 после обмена: 7 8 3 4 
Список L2 после обмена: 5 6 1 2 
```
```
Введите элементы списка L1 (четное количество чисел через пробел):
1
Введите элементы списка L2 (четное количество чисел через пробел):
1 2
Ошибка: оба списка должны иметь четное количество элементов!
```
```
Введите элементы списка L1 (четное количество чисел через пробел):
1 2 3 4
Введите элементы списка L2 (четное количество чисел через пробел):
1
Ошибка: оба списка должны иметь четное количество элементов!
```
### 4.1.
Дано целое число K (> 0), текстовый файл с именем name1, содержащий английские слова, и строка name2. Записать в текстовый файл с именем name2 все слова из исходного файла, длина которых не превосходит K, сохранив исходный порядок их следования и располагая каждое слово на новой строке. Использовать алгоритм remove_copy_if.
1. Считываю число K
2. Открываю входной и выходной файлы
3. Использую remove_copy_if с условием "длина слова > K"
4. Копирую в выходной файл только слова длиной <= K
5. Вывожу содержимое выходного файла
```
Введите K (> 0): 3
Файл output.txt создан с словами длиной <= 3
// Содержимое выходного файла:
// cat
// dog
```
```
Введите K (> 0): 0
Ошибка: K должно быть больше 0!
```
```
Введите K (> 0): -5
Ошибка: K должно быть больше 0!
```
```
// Если файла нет в директории
Введите K (> 0): -5
Ошибка: не удалось открыть файл name1.txt
```
### 5.2. 
Дан дек D. Удалить последний нулевой элемент дека. Если нулевых элементов нет, то дек не изменять. Использовать алгоритм find с обратными итераторами и функцию-член erase.
Указание. Алгоритм find может возвращать обратный итератор, однако функция-член erase не позволяет его использовать для удаления элемента. Необходимо перейти от обратного итератора r к связанному с ним обычному итератору, используя функцию-член обратного итератора r.base(). При этом следует учитывать, что функция r.base() возвращает итератор, связанный с элементом, следующим за тем, с которым связан обратный итератор r. Поэтому в функции-члене erase следует указать одно из следующих выражений (предполагается, что r — это обратный итератор, который вернул алгоритм find, и этот итератор отличен от rend): -- r.base() или (++r).base().
1. Считываю дек с числами
2. Использую find с обратными итераторами для поиска последнего нуля
3. Если ноль найден, преобразую обратный итератор в обычный
4. Удаляю найденный элемент через erase
5. Вывожу результат
```
Введите элементы дека D (через пробел):
0 1 2 3 0
Исходный дек D: 0 1 2 3 0
Дек D после удаления последнего нуля: 0 1 2 3
```
```
Введите элементы дека D (через пробел):
1 2 3 4 5
Исходный дек D: 1 2 3 4 5
Нулевых элементов не найдено, дек не изменен
```
```
Введите элементы дека D (через пробел):

Ошибка: дек пустой!
```
### 6.2.
Даны числа A и B и векторы V1 и V2. Добавить в начало каждого вектора 5 элементов со значениями A, а в конец — 5 элементов со значениями B. При преобразовании вектора V1 использовать два вызова алгоритма fill_n с функциями inserter и back_inserter (данные функции возвращают итераторы вставки), при преобразовании вектора V2 использовать два вызова функции-члена insert.
Замечание. Второй способ является более эффективным
1. Считываю два вектора V1 и V2
2. Считываю числа A и B
3. Для V1: использую fill_n с inserter для добавления 5*A в начало
4. Для V1: использую fill_n с back_inserter для добавления 5*B в конец
5. Для V2: использую insert для добавления 5*A в начало и 5*B в конец
```
Введите элементы вектора V1 (через пробел):
1 2 3
Введите элементы вектора V2 (через пробел):
4 5 6
Введите число A для добавления в начало: 1
Введите число B для добавления в конец: 2
Исходный вектор V1: 1 2 3
Исходный вектор V2: 4 5 6
Вектор V1: 1 1 1 1 1 1 2 3 2 2 2 2 2 2
Вектор V2: 1 1 1 1 1 4 5 6 2 2 2 2 2 2
```
### 7.12.
Дан вектор V с четным количеством элементов. Известно, что первая половина вектора уже отсортирована по возрастанию. Отсортировать все элементы вектора по возрастанию, выполнив вначале сортировку его второй половины алгоритмом sort, а затем слияние обеих половин алгоритмом inplace_merge. Выводить новое содержимое вектора V после применения каждого алгоритма.
1. Считываю вектор с четным количеством элементов
2. Проверяю что первая половина отсортирована
3. Сортирую вторую половину вектора
4. Использую inplace_merge для слияния двух отсортированных половин
5. Вывожу результат после каждой операции
```
Введите элементы вектора V (четное количество чисел через пробел):
1 3 5 7 2 4 6 8
Исходный вектор V: 1 3 5 7 2 4 6 8
После сортировки второй половины: 1 3 5 7 2 4 6 8
После слияния половин: 1 2 3 4 5 6 7 8
```
```
Введите элементы вектора V (четное количество чисел через пробел):
1 2 3
Ошибка: вектор должен иметь четное количество элементов! 
```
```
Введите элементы вектора V (четное количество чисел через пробел):

Ошибка: вектор пустой!
```
```
Введите элементы вектора V (четное количество чисел через пробел):
5 3 1 7 2 4 6 8
Ошибка: первая половина вектора НЕ отсортирована по возрастанию!
```
### 8.1.
Дан список L. Получить вектор V вещественных чисел, содержащий значения среднего арифметического для всех пар соседних элементов исходного списка (количество элементов вектора V должно быть на 1 меньше количества элементов списка L). Например, для исходного списка 1, 3, 4, 6 полученный вектор должен содержать значения 2.0, 3.5, 5.0. Использовать алгоритм adjacent_difference с итератором вставки и функциональным объектом, а также функцию-член erase для вектора V.
1. Считываю список L
2. Использую adjacent_difference для вычисления средних значений соседних элементов
3. Функция возвращает (a + b) / 2 для каждой пары
4. Удаляю первый элемент результата (он равен первому элементу L)
5. Вывожу вектор со средними значениями
```
Введите элементы списка L (минимум 2 числа через пробел):
10 20 30
Исходный список L: 10 20 30
Вектор V со средними значениями: 15 25
```
```
Введите элементы списка L (минимум 2 числа через пробел):
10
Ошибка: список должен содержать не менее 2 элементов!
```
### 9.1.
Дан вектор V0, целое число N (> 0) и набор векторов V1, …, VN. Известно, что размер вектора V0 не превосходит размера любого из векторов V1, …, VN. Найти количество векторов VI, I = 1, …, N, в которых содержатся все элементы вектора V0 (без учета их повторений). Использовать алгоритм includes, применяя его в цикле к двум множествам, одно из которых создано на основе вектора V0, а другое на очередной итерации содержит элементы очередного из векторов VI, I = 1, …, N.
1. Считываю базовый вектор V0 и набор векторов для проверки
2. Преобразую V0 в множество S0 (убираю дубликаты, сортирую)
3. Для каждого проверяемого вектора преобразую его в множество S_i
4. Использую includes для проверки содержит ли S_i все элементы S0
5. Считаю количество векторов прошедших проверку
```
Введите элементы базового вектора V0 (через пробел):
1 2 3
Введите количество векторов для проверки: 4
Введите элементы вектора 1 (через пробел):
1 2 3 4 5
Введите элементы вектора 2 (через пробел):
1 3 5 7 9
Введите элементы вектора 3 (через пробел):
2 4 6 8
Введите элементы вектора 4 (через пробел):
1 1 2 2 3 3 4 4
Базовый вектор V0: 1 2 3
Вектор 1 содержит все элементы V0
Вектор 4 содержит все элементы V0
Количество векторов, содержащих все элементы V0: 2
```
```
Введите элементы базового вектора V0 (через пробел):

Ошибка: базовый вектор не может быть пустым!
```
```
Введите элементы базового вектора V0 (через пробел):
1 2 3
Введите количество векторов для проверки: 0
Ошибка: количество векторов для проверки должно быть больше 0!
```
### 10.2.
Дан вектор V, элементами которого являются английские слова, набранные заглавными буквами. Определить суммарную длину слов, начинающихся с одной и той же буквы, и вывести все различные буквы, с которых начинаются элементы вектора V, вместе с суммарной длиной этих элементов (в алфавитном порядке букв); длину выводить сразу после соответствующей буквы. Использовать вспомогательное отображение M, ключами которого являются начальные буквы элементов вектора V, а значениями — суммарная длина этих элементов. При заполнении отображения M не использовать условные конструкции (достаточно операций индексирования [], инкремента и функции-члена size для строк). Элементы вектора V (при заполнении отображения M) и элементы отображения M (при выводе полученных результатов) перебирать в цикле с параметром-итератором соответствующего контейнера.
1. Считываю вектор английских слов
2. Создаю словарь, где ключ - первая буква, значение - суммарная длина
3. Для каждого слова получаю первую букву и добавляю длину слова в словарь
4. Map автоматически сортирует ключи по алфавиту
5. Вывожу пары "буква - суммарная длина"
```
Введите английские слова заглавными буквами (через пробел):
APPLE BANANA ANT BALL CAT CAR DOG
Исходный вектор V: APPLE BANANA ANT BALL CAT CAR DOG
Результат:
A - 8
B - 10
C - 6
D - 3
```
```
Введите английские слова заглавными буквами (через пробел):

Ошибка: не введено ни одного слова!
```
